

# 소프트웨어공학 개요

1. 소프트웨어 개발에 관한 전반적인 흐름
2. 소프트웨어 공학을 비롯한 프로젝트 관리

- 소프트웨어를 설계하기 위한 기획 단계, 설계 , 운영, 유지 보수를 해야 하는 흐름이 있다.



## 정의

### 프로그램 (Program)

> source code



### 소프트웨어 (Software)

> **source code** (프로그램을 운영하는 소스코드)와 함께 이로 인한
>
> **산출물** (자료구조, DB구조, 테스트 결과 등)과
>
> **메뉴얼** (어떻게 그 소프트웨어를 사용하는가)이 있다.



#### 소프트웨어의 분류

##### 정보관리 소프트웨어

- 정보 제공 및 관리 소프트웨어
- 정보를 입력하거나 편집, 그리고 관리하는 소프트웨어
- DB에 자료를 저장한 후, 검색을 통해 사용자가 원하는 형태로 정보를 제공
- 예) 인터넷뱅킹 시스템, 대학의 종합정보 시스템, 예약 시스템 등

##### 제어 소프트웨어

- 각종 장비 혹은 센서를 이용하거나 기기들의 동작을 제어하는 소프트웨어
- 예) 교통 신호 제어, 의료기기 제어 공장장비 제어 등

##### 임베디드 소프트웨어

- 장비나 기기에 내장된 형태의 소프트웨어
- 예) 가전제품내의 소프트웨어, 각종 공정제어 시스템 내의 소프트웨어



#### 소프트웨어의 특징

##### 제조가 아닌 개발

###### 제조

> 정해진 틀에 맞춰 일정하게 생산하는 것

###### 개발

> 개인 능력 별 결과물 차이가 매우 큼



##### 소모가 아닌 품질 저하

###### H/W (하드웨어)

> 오래 사용하면 부품이 닳고, 고장 발생 빈도 높고, 기능도 떨어짐

###### S/W (소프트웨어)

> 오래 사용해도 닳지 않고, 고장 발생 빈도 낮고, 기능도 동일함



#### 소프트웨어 개발의 문제점

- 하드웨어는 CPU 속도, 메모리 용량 등 많이 발전해나가는데, **소프트웨어 개발은 발전 속도가 느리다**.
  - 통신 환경이 4G에서 5G로 바뀌었는데, 속도가 빨라지지만 내가 쓰는 소프트웨어는 달라지지 않는다.
- 새로운 소프트웨어에 대한 **사용자 요구가 증가한다**.
- S/W 개발에도 관리가 필요하다.
  - 비용 관리/ 일정 관리/ 개발자 관리 :arrow_right: PMBOK를 활용한 적극적인 프로젝트 관리 필요
- **개발과정이 복잡해지고 있음**
- 참여 인력이 많아지고 있음
- 개발기간이 길어지고 있음
  - 예를 들어 오래전에 개발된 테트리스는 1~2명, 즉 적은 인원이 개발했지만, 현재 FIFA와 같은 게임은 많은 사람들이 붙어 개발하고, 또 그만큼 개발과정이 복잡해지며, 또 인력이 많기 때문에 개발 기간이 길어진다.



#### 소프트웨어공학의 정의

> 품질 좋은 소프트웨어를 **경제적**으로 개발하기 위해
>
> 1. **계획**을 세우고, 
> 2. **개발**하며,
> 3. **유지 및 관리**하는 전 과정에서
> 4. 공학, 과학 및 수학적 원리와 방법을 적용하여 필요한 **이론과 기술 및 도구들**에 관해 연구하는 학문



#### 소프트웨어공학의 목표

- 개발 과정에서의 생산성 향상
- 고품질의 소프트웨어 생산 → 사용자 만족



#### 소프트웨어 공학의 특성

##### 공학의 특성

- 제약 사항 : 정해진 기간, 주어진 비용 (한정된 자원)

  → 과학적 지식을 활용하여 문제를 해결하는 데 한정된 기간과 비용의 제약을 받음

##### 소프트웨어 공학

- 소프트웨어 + 공학
- '소프트웨어 개발 과정에 공학적인 원리를 적용하여 소프트웨어를 개발'
- S/W개발의 어려움 해결
- **효율**적 개발을 통한 **생산성** 향상
- **고품질 소프트웨어 제품**



#### 소프트웨어 개발 생명주기

- 소프트웨어 개발 생명주기 (SDLC Software Development Life Cycle)
- 계획 단계에서 유지 보수 단계에 이르기까지 이르는 일련의 과정



# 소프트웨어 개발 프로세스

## 프로세스의 정의

### 프로세스

- 일이 처리되는 과정이나 공정
- 즉, 주어진 일을 해결하기 위한 목적으로 그 순서가 정해져 수행되는 일련의 절차

### 프로세스의 목적

- 이전에 얻은 노하우 전달 → 시행착오 감소→ 빠르게 적응
- 가이드 역할



## 소프트웨어 프로세스의 정의

### 소프트웨어 개발에서의 프로세스

- 작업 (task) 순서의 **집합 + 제약조건** (일정, 예산, 자원)을 포함하는 일련의 활동 (activity)
- 작업(task): SW를 개발할 때 일을 수행하는 작은 단위

### (좁은 의미) 소프트웨어 개발 프로세스

- SW 제품을 개발할 때 필요한 **절차, 과정, 구조**
- 사용자의 요구사항을 SW시스템으로 구현하기 위한 과정

### (넓은 의미) 소프트웨어 개발 프로세스

- 절차, 구조, **방법, 도구, 참여자까지** 모두 포함
- SW개발 목적을 이루는데 필요한 통합적 수단
- 서비스 회사이든, SI회사이든 프로세스를 통해 서비스를 개발하고 프로그램을 개발한다.



## 소프트웨어 개발 프로세스

1단계: 계획

- 어떤 소프트웨어를 만들것인지 계획하기

2단계: 요구분석

- 소프트웨어는 어떤 기능이 필요하고, 소비자와 시장에서 어떤 것들을 요구하는지 파악하고 분석하기

3단계: 설계

- 실제 전반적인 흐름에 대한 설계
- 코딩에 대한 설계

4단계: 구현

- 설계를 바탕으로 구현

5단계: 테스트

- 요구사항대로 잘 구현되었는지 테스팅

6단계: 유지보수

- 개발한 소프트웨어를 유지 및 보수



## 소프트웨어 프로세스모델의 정의

### 소프트웨어 프로세스 모델의 정의

- 소프트웨어 개발 생명주기 (SDLC Software Development Life Cycle)

- SW를 어떻게 개발할 것인가에 대한 전체적인 흐름을 체계화한 개념

- 소프트웨어를 계획하고, 요구분석하고, 개발, 그리고 유지보수, 최종 폐기까지 전 과정을 다룸



### 소프트웨어 프로세스 모델의 목적

- 프로세스는 '가이드'이다. 소프트웨어의 전 과정을 하나하나 따라갈 수 있도록 정의해둔 것이다.

- 공장에서 제품을 생산하듯이 소프트웨어 개발의 전 과정을 하나의 프로세스로 정의 
- 주어진 예산과 자원으로 개발하고 관리하는 방법을 구체적으로 정의
- 고품질의 소프트웨어 제품 생산을 목적으로 함.



### 소프트에어 프로세스 모델의 역할

- 프로젝트에 대한 전체적인 **기본 골격**을 세워줌
  - 기본 골격: 서비스를 만드려고 하는데 서비스를 어떠한 예산으로, 얼만큼의 기간으로 내가 만들어서, 어떠한 과정으로 어떻게 어떠한 조직으로 운영할 것인지 골격을 세워야 한다.
- **일정 계획을 수립**할 수 있음
- 개발 비용 산정뿐 아니라 여러 자원을 산정하고 분배할 수 있음
  - 금전, 공간, 인력 배치 등 모든 자원을 다 포함해 산정하고 분배해야 한다.
- 참여자 간에 의사소통의 기준을 정할 수 있음
  - 조직 내, 그리고 조직과 고객간의 소통 기준으로 삼는다.
- 용어의 표준화를 가능케 할 수 있음
  - 문서를 주고 받으면서, 프로젝트에 관련된 단계를 밟으면서 개발에 대한 설명, 자원 등에 대한 용어를 설명하고 표준화 해야한다.
- 개발 진행 상황을 명확히 파악할 수 있음
- 각 단계 별로 생성되는 문서를 포함한 산출물을 활용하여 검토할 수 있게 해줌
  - 원래 설계되었던 것처럼 개발이 잘 되었다는 것을 증명하기 위한 것이다.

→  필요한 이유: 효율적으로 잘 개발하기 위한 것, 원래 목적과 같게 개발하기 위한 것, 기획/개발자 입장에서 애초에 목적대로 잘 개발되었다는 것을 확인하기 위함이다.



## 소프트웨어 프로세스 모델의 종류

### 선형순차적모델

#### Linear Sequential 모델,waterfall 모델 (폭포수 모델), classic life cycle

요구를 확인하고, 분석하고, 설계하고, 코딩하고, 테스팅하고, 유지보수한다.



##### 폭포수 모델

###### 폭포수 모델의 장점

- 관리의 용이
- 체계적인 문서화
- **요구사항의 변화가 적은 프로젝트에 적합**



###### 폭포수 모델의 단점

- 각 단계는 **앞 단계가 완료되어야** 수행할 수 있다.

- 각 단계의 결과물이 완벽한 수준으로 작성되어야 다음 단계에 오류를 넘겨주지 않는다.

  →  요구사항 파악이 덜 되었을 때 진행한다면, 설계가 뒤엉키거나 빠지는 상황이 발생할 수 있다.

- 사용자가 중간에 가시적인 결과를 볼 수 없어 답답해 할 수 있다.

  →  내가 원하는 것이 맞는지 잘 모르기 때문에, 고객들은 서비스에 대한 흐름과 디자인을 알고 있지만 그 기능에 대해서 이해를 잘 못하는 경우가 있다. 어떠한 컨텐츠를 가지고 어떤 서비스를 만들고 싶다는 생각이 있지만 정확하게 답을 낼 수 없어서 중간중간 진행상황을 보고 싶을 때 볼 수 없다는 점이 단점이다.



##### V모델

- 소프트웨어 개발 프로세스로 폭포수 모델의 확장된 형태
- 이 프로세스는 오른쪽 그림과 같이 코딩 단계에서 위쪽으로 꺾여서 알파벳 V자 모양으로 진행
- V모델은 개발 생명주기의 각 단계와 그에 상응하는 소프트웨어 시험 각 단계의 관계를 보여줌
- V모델은 소프트웨어 개발의 각 단계마다 상세한 문서화를 통해 작업을 진행하는 방법을 사용
- 테스트 설계와 같은 테스트 활동을 코딩 이후가 아닌 **프로젝트 시작 시**에 함께함
- 전체적으로 많은 양의 프로젝트 비용과 시간을 소비함
- 순차적으로 진행한다는 흐름이 폭포수 모델과 같고, 각 단계에서 테스팅을 진행한다는 것이 폭포수 모델과 다름!



### 선형순차적모델 & 진화적 프로세스 모델

- 선형순차적모델을 통해 모두 개발한 후인데, 사용자가 원하는 것이 아니라고 할 때가 있었기 때문에, 진화적인 프로세스 모델이 등장했다.

- 선형순차적 모델의 대표: 폭포수 모델

- 진화적 프로세스 모델의 대표: 프로토타입 모델



### 진화적 프로세스 모델

#### 프로토타입

- 대량 생산에 앞서 미리 제작해보는 원형 또는 **시제품**으로, 제작물의 모형
- 자동차 모터쇼에서 컨셉카를 통해 반응을 보듯이, 소프트웨어는 조금 더 쉽게 시제품을 만들어 보고 고객의 요구사항을 조금 더 디테일하게 살펴본다.



#### 소프트웨어 개발에서의 프로토타입

- 정식 절차에 따라 완전한 소프트웨어를 만들기 전에 사용자의 요구를 받아 일단 모형을 만들고, 이 모형을 사용자와 의사소통 하는 도구로 활용
- 사용자의 요구를 판단하기 위해 모형을 만들고, 이것을 기반으로 사용자와 커뮤니케이션 하는 것이다.



#### 프로토타입 모델의 개발 생명주기

1. 사용자가 요구사항을 주고, 

2. 간단하게 설계를 한다.

3. 그 후, 프로토타입을 만든다.

4. 사용자와 함께 프로토타입을 평가한다.

   - 사용자가 :ok_hand: 하면 개발이 시작되는 것이고, 

   - 사용자가 🙅‍♀️ 하면 다시 요구사항을 정의하러 1번으로 돌아간다.

5. 프로토타입이 받아들여지면, 실제 개발 단계에 들어간다.



#### 프로토타입 모델의 장단점

##### 장점

- 반복된 요구사항 정의를 통해 사용자 요구가 충분히 반영된 요구 분석 명세서 작성
- 초기 프로토타입 사용을 통한 새로운 요구사항 발견
- 프로토타입 사용을 통한 완성품의 예측 가능

##### 단점

- 반복적 개발을 통한 **투입 인력 및 비용 산정**의 어려움
- 프로토타이핑 과정에 대한 **통제 및 관리의 어려움**
- 불명확한 개발 범위로 인한 **개발 종료 및 목표의 불확실성**



보통 회사들이 프로토타입 모델을 사용할 때는: 

- 새로운 서비스를 만들기 위해 가오픈을 해놓고, 사용자가 사용하면서 피드백을 주면 그것을 바탕으로 개선해나간다.
- 예시: 네이버 모바일 홈 



### 나선형모델

> 진화적 프로토타입 모델 + 위험 분석
>
> 요구사항만 분석하는 것이 아니라,**요구사항**에 더해서 실제 **운영하면서 발생할 수 있는 위험요소**까지 분석해서 같이 반영하는 것



#### 위험 분석 단계의 위험 요소의 예

- 번번히 변경되는 요구사항
- 팀원들의 경험 부족
- 결속력이 떨어지는 팀워크
- 프로젝트 관리 부족 



#### 나선형모델 모델의 개발 절차

>  지속적으로 설계하고 →   구현하고 →   평가한 후에 -→  이 평가 결과를 기반으로 어떠한 문제점이 있는지 파악하고 →   다시 설계 stage로!
>
> 계속 보완해나가다 보면 최종 목적지, 최종 software을 개발할 수 있을 것이다.

(1) 계획 및 요구 분석 단계

(2) 위험 분석 단계

(3) 개발 단계

(4) 사용자 평가 단계



#### 나선형모델의 장단점

##### 장점

- 사전 위험 분석을 통한 돌출 위험 요소 감소   → 프로젝트 중단 확률 감소
- 사용자 평가에 의한 개발 방식  → 요구가 충분히 반영된 제품  → 사용자의 불만 감소

##### 단점

- 반복적 개발에 의한 프로젝트 기간 연장의 가능성
- **반복 회수의 증가**에 따라 프로젝트 **관리의 어려움**
- 위험 관리의 중요  → 전문가 필요에 따른 부담 (비용의 증가)



### 단계적 개발 모델

> 한 번에 묶어서 보는 것이 아니라, '단계별로' 개발해보자

#### 릴리즈 구성 방법에 따른 분류

- 점증적 개발 방법: 단계별로 개발해보자
- 반복적 개발 방법: 개발한 후에 반복적으로 보완해나가면서 개발해나가자.



#### 통합 프로세스 (UP) 모델

아래의 모든 프로세스들이 동시에 (도입 때부터) 시작된다.

모든 과정들이 각 단계별로 서로 연관되어 진행된다.

- 비즈니스 모델링
- 요구 사항 정의
- 분석 및 설계
- 구현
- 테스트
- 배치
- 형상 (변화) 관리
- 프로젝트 관리
- 환경 점검



##### 통합 프로세스 방법

- 비즈니스 모델링
- 초기 계획
- 프로젝트 계획
- 형상 (변화) 관리
  - 요구사항 정의
  - 분석 및 설계
  - 구현
  - 테스트
  - 평가
- 배치



##### 통합프로세스 모델의 절차

1. 도입 단계: inception phase
   - 도입 자체에 대해 모델링하고 분석하는 것
2. 구체화 단계: elaboration phase
   - 설계하고 구축하는 과정
3. 구축 단계: construction phase
   - 구축하고 테스팅하는 과정
4. 전이 단계: transition phase
   - 테스팅하고 배포하는 과정
5. 도입/ 구체화/ 구축/ 전이 단계의 공통 작업 



#### 애자일 프로세스 모델

##### 애자일 (agile)

> 날렵한, 민첩한



##### 애자일 프로세스 모델

- 고객의 요구에 **민첩하게 대응**하고 그**때그때 주어지는 문제를 풀어나가**는 방법론
- 고객의 요구사항에 빨리빨리 반응, 대응할 수 있는 방식



##### 애자일의 기본 가치(애자일 선언문)

- 프로세스와 도구 중심이 아닌, 개개인과의 상호 소통 중시 (어떻게 고객들과 소통하느냐)

- 문서 중심이 아닌, 실행 가능한 소프트웨어 중시

- 계약과 협상 중심이 아닌, 고객과의 협력 중시

- 계획 중심이 아닌, 변화에 대한 민첩한 대응 중시

  

##### 애자일의 개발 방법

- 반복적인 개발을 통한 잦은 출시를 목표로 함
- 계획하고, 개발하고, 테스팅하고, 데모를 내고 이 과정의 반복! (Sprint Planning - Development - Testing - Demo)
- 서비스의 기능이 자주 바뀌거나 디자인이 자주 바뀌는 경우가 애자일 방식의 개발을 적용한 것이다.
  - 지속적으로 고객의 요구를 반영해 서비스를 만든다.



##### 스크럼 개발 프로세스

- 소프트웨어 개발보다는 **팀의 개선**과 **프로젝트 관리**를 위한 애자일 방법론
- 경험적 관리 기법 중 하나
- 구체적인 프로세스를 명확하게 제시하지 않음
- 개발 팀(조직)을 운영하는 **효율적인 운영 방식** (지침)



##### 스크럼 방식의 장점

- 실행 가능한 제품을 통해 **사용자와의 충분한 의견 조율 가능**
- 일일 회의를 통한 팀원들 간의 **신속한 협조와 조율 가능**
- 다른 개발 방법론들에 비해 **단순하고 실천 지향적**
- 프로젝트 진행 현황을 통한 신속하게 **목표**와 **결과 추정 가능**, **목표에 맞는 변화 시도 가능**
  - 변화에 대해 쉽게, 빠르게 대처할 수 있다.



##### 스크럼 방식의 단점

- **추가 작업 시간 필요**
  - 반복 주기가 끝날 때마다 실행 가능하거나 테스트할 수 있는 제품을 만들어야 하기 때문
  - 불필요한 시간 소모 (하지만 고객과의 커뮤니케이션을 위해 필요하다)
- 일일 스크럼 회의를 15분 안에 마쳐야 함
- 길어지는 회의 시간으로 인한 작업의 방해
- 투입 공수 불측정에 따른 효율성 평가 불가
- 투입 공수 불측정으로 인해 얼마나 효율적으로 수행되었는지 모름
- 프로세스 품질 평가 불가
- 프로세스 품질 미평가로 인한 품질 관련 활동이 미약하고 품질의 정도를 알 수 없음 



##### 스크럼방식

- 30일마다 프로토타입을 만드는 애자일 방법론
- 개발주기를 30일
- 스프린터 (Sprint) 또는 이터레이션(Iteration)
- 매일 15분씩 회의를 하며 이슈나 우선사항을 서로 공유



##### XP(eXtreme Programming)

- 의사소통, 피드백, 단순함, 용기, 존중에 가치를 두고 있는 방법론 
- 고객과 2주 정도의 반복 개발을 하며 테스트 강조
- 고객과 어떻게 의사소통을 하고, 피드백을 할 것인지에 대해 강조



# 소프트웨어 개발단계: 계획/ 요구분석

## 소프트웨어 개발 계획

### 소프트웨어 개발 계획

- 비용, 기간, 자원(인력, 공간, 장비 등) 계획 필요
- 기간과 어떠한 비용으로 할애해서 쓸 것인지 계획

### 계획 없는 소프트웨어 개발

- 일정 지연, 비용 초과, 품질 저하 → 유지보수 비용 증가
- 그냥 생각만하고 개발을 시작하면, 예기치 않은 상황과 문제, 그리고 자원이 발생할 수 있다. 이로 인해 일정이 지연되고, 비용이 초과 되며, 품질이 저하될 수 있다.



### 문제의 정의

- 소프트웨어 개발 시작 단계

- "무엇"을 개발할 것인가 → 개발 범위를 결정

- "프로젝트의 초기 타당성과 초기 계획을 작성할 수 있는 기초로 활용"



### 타당성 분석

#### 1. 경제적 타당성

- 투자 효율성/ 시장성
- 만들 가치가 있는지 파악

#### 2. 기술적 타당성 (technical feasibility)

- 구현 가능한가?/ 하드웨어 성능 /개발자의 기술력
- 성능이 따르는지, 구현이 가능한지 파악

#### 3. 법적 타당성 (legal feasibility)

- 개발용 소프트웨어와 도구의 사용에 대한 법적 문제 검토
- 지적 소유권과 프로그램 보호법에 대한 검토

#### 예시

- Marvel Series와 같은 것을 개발할 때, 만들 수 있는지 자문을 받는다.
  - Iron Man의 Suit가 기술적으로 구현이 가능할까? 
- Apple Smart Watch: 심전도 체크는 한국에서 금지 됐다. 한국에서는 심전도 체크는 의료기기만 가능하기 때문이다.



### 개발비 산정의 어려움

#### 소프트웨어 개발 비용 예측

- 개발자의 능력에 따른 생산성의 차이
  - 어떤 개발자를 쓸 것인지, 초급/중급/고급 (개발 기간에 따른 생산성)
- 다양한 개발 프로세스로 인한 표준화/자동화의 어려움 → 명확한 개발비 산출의 어려움
  - 오토 서비스냐, 홈페이지냐, 앱이냐, 임베디드냐 등 다 제각각



#### SW 개발 비용에 영향을 주는 요소

##### 1. 프로그램 자질

- 초급 프로그래머와 고급 프로그래머의 생산성 차이

##### 2. 소프트웨어 복잡도

- 브룩스의 법칙: 애플리케이션 개발 < 유틸리티 개발 < 시스템 프로그램 개발
  - 어떤 어플리케이션을 만드냐에 따라 복잡도가 달라진다.
- 소프트웨어 복잡도: 개발 비용에 영향을 미침

##### 3. 소프트웨어 크기

- 소프트웨어의 기능이 많아지거나 소프트웨어가 커지면,
  참여 인력 증가, 개발 기간 길어짐, 복잡도 커짐

##### 4. 가용 시간

- 관리자들의 잘못된 생각: 인력/자원 증가는 개발 기간 단축이라고 생각
  - 그러나 실제로 그렇지 않다.

##### 5. 요구되는 신뢰도 수준

- 높은 신뢰도의 소프트웨어 개발은 개발 비용의 증가

##### 6. 기술수준

- 고급 언어 사용은 저급 언어의 사용보다 5~10배 생산성 증가
- 이전에 나온 언어들 (C, C++, Assembly)등에 비해 최근에 나온 언어들의 생산성이 증가되었다.



#### 하향식 산정 기법

##### 전문가 판단 기법

- 경험이 많은 **전문가가 개발 비용을 산정** → **신뢰성 높음**
- 짧은 시간에 개발비를 산정하거나 입찰에 응해야 하는 경우 많이 사용
- <u>단점</u>: 수학적 계산 방법보다 경험에만 의존할 경우 부정확할 수 있음
  - 예) 델파이 기법



#### 상향식 산정 기법

##### 세부 <u>작업 단위별</u>로 비용 산정한 후 전체 비용 합산

###### 1. 원시 코드 라인 수 LOC 기법

- 원시 코드 라인 수의 비관치, 낙관치, 중간치를 측정 후 예측치를 구해 비용산정
- 이전의 방법! (불필요한 코드를 넣을 가능성이 있다)

###### 2. 개발 단계별 노력 (effort per task) 기법

- 생명주기의 **각 단계별**로 노력 (M/M)을 산정



#### 수학적 산정 기법

##### 상향식 비용 산정 기법

##### 경험적 추정 기법 또는 실험적 추정 기법

###### 1. COCOMO  방법

- SW규모 (LOC) 예측한 후 SW 종류에 따라 각 비용 산정 공식에 대입하여 비용 산정

###### 2. Putnam 방법

- 소프트웨어 생명주기의 전 과정에 사용될 노력의 분포를 가정해 줌

###### 3. 기능 점수(FP) 방법

- 기능 점수를 구한 후 이를 이용해 비용 산정



### SW 개발 프로젝트에서의 일정 계획

#### 일정 계획

- 작업 순서 결정, 소작업의 개발 기간, 순서, 필요한 자원 등의 일정 계획



#### 작업 분할 구조도 (WBS: Work Breakdown Structure)

- 어떠한 단계별로 할 것인지 세분화해서 계층 구조로 분류

- 프로젝트 목표를 달성하기 위해 필요한 활동과 업무를 세분화하는 작업
- 프로젝트 구성 요소들을 계층 구조로 분류
- 프로젝트의 전체 범위 정의
- 프로젝트 작업을 세분화



#### PERT/ CPM

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Pert_chart_colored.svg/1200px-Pert_chart_colored.svg.png" style="zoom: 33%;" />

- WBS의 작업 순서, 소요 기간 등을 네트워크 형태의 그래프로 표현
- **어떤 작업이 중요한지**, 
  또 **일정에 여유가 있는 작업**은 어떤 것인지 찾아내어 
  중점 관리를 해야 하는 작업을 명확히 하는 데 사용
- **어떤 작업에 특히 주의를 기울여야 하는지**,
  전체 프로젝트 완료 기간을 단축하기 위해서는 
  어떤 작업들을 단축하는 것이 가장 경제적인지 등
  관리자의 고민에 답을 주기 위해 필요한 도구



#### 간트 차트 (Gantt chart)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/GanttChartAnatomy.png/300px-GanttChartAnatomy.png)

- 프로젝트 일정 관리를 위한 바 형태의 도구
- 일정의 진행사항을 차트로 관리한다.



### 위험 관리 절차

#### 위험 요소 식별

#### 위험 분석

- 위험 요소가 발생할 가능성과 영향력을 판단
- 과거 프로젝트에서 데이터와 위험을 분석한 경험이 많은 개발자에 의존해 판단

#### 위험 계획 수립

- 위험을 처리하는 위험 <u>대응 방안 수립</u>

#### 위험 감시

- 식별된 위험 요소의 발생 확률과 변화 등을 관리
- 예측한 위험의 실제 발생 여부 확인



## 요구 분석

### 요구 사항과 요구 분석 명세서

#### SW개발의 목적: 개발된 소프트웨어의 <u>고객 만족</u>

#### 1. 고객 만족을 위한 특성

- 적시성/ 유연성/ 통합

#### 2. 고객 만족의 개발 조건

- 고**품질**/ 정해진 **기간**/ 주어진 **예산**

#### 3. 요구 사항 (requirement)

- 사용자와 개발자 간에 합의한 개발 범위에서 시스템이 제공해야 하는 기능
- 고객과 개발자 간에 합의되어져 있는 기능

#### 4. 요구 분석 명세서

- 개발 초기에 사용자의 요구 사항 (비기능 요구 사항 포함)을 추출하여 정리한 문서 (WHAT)
- 위 기능을 정리한 것이 요구 분석 명세서



#### 요구 분석 과정

사용자 요구 분석 → SW목표수립  → 모델링 → 요구분석명세서 

- 사용자 요구를 듣고 분석
- 어떤 소프트웨어를 만들겠다
- 소프트웨어를 어떻게 구성하겠다
- 다시 고객에게 검증을 받는다.



#### 요구 분석

- 소프트웨어 요구 사항 정의를 위해 사용자의 요구 사항을 조사하고 확인하는 과정
- 소프트웨어 개발 생명주기의 첫 단계
- 소프트에어 개발 성패의 열쇠



### 요구분석절차

1. **자료 수집**: 현행 시스템 파악, 실무 담당자와 인터뷰, 현재 사용하는 서류 검토
   - 정확한 정보를 수집하고, 클라이언트의 요구사항을 잘 듣는 것
2. **요구사항 도출**: 수집한 자료 정리 및 분류 → 개발에 반영할 요구 사항 도출
3. **문서화**: 요구 분석 명세서 작성
4. **검증**: 요구 분석 명세서 <u>검토</u> → 모순 사항, 빠뜨린 사항 등 점검



### 요구사항 분류

![capture-5752808](images/Software Enginnering/capture-5752808.png)



### 품질

- 요구사항의 첫번째는 품질이다.

#### 1) 신뢰성

- 소프트웨서의 신뢰는 앱이 잘 동작하고, 멈추지 않고, 예기치 않은 종료 없이 사용 가능한 것이다.

- 신뢰: 소프트웨어를 믿고 사용할 수 있는 것 (고장없이 사용)
- 신뢰도: 장애 없이 동작하는 시간의 비율

##### 신뢰도 측정

- 고장 간 평균 시간 (MTBF)과 이용 가능성 (가용성)을 척도로 사용
- MTBF = MTTF + MTTR
  - MTBF (고장 간 평균 시간, Mean Time Between Failure): 고장에서 다음 고장까지의 평균 시간
  - MTTF (평균 실패 시간, Mean Time To Failure): 수리한 후 다음 고장까지의 평균 시간
  - MTTR (평균 수리 시간, Mean Time to Repair): 고장 발생 시점에서 수리 시까지의 평균 시간

##### 이용가능성 availability = MTTF/(MTTF+MTTR)X100%

- 이용 가능성 (가용성): 주어진 시점에서 프로그램이 요구에 따라 작동되고 있을 가능성

#### 2) 성능

- 사용자가 시스템에 어떤 요구를 했을 때, 해당 기능을 <u>정상적으로 수행</u>하는 것은 물론, 사용자가 원하는 조건 (응답 시간, 데이터의 처리량 등)을 만족시키는 것
- 응답 시간이 느리지 않는 것

#### 3) 보안성

- 인증을 받지 않은 사람이 시스템에 접근하는 것을 처음부터 막아 시스템과 데이터를 보호
- 인증 받은 사람에 한해서 시스템을 사용할 수 있도록 만드는 것

#### 4) 안전성

- 작동하는 모든 시스템이 소프트웨어 오류로 인해 <u>인명 피해가 발생하지 않아야 함</u>
- 교통 신호를 제어하는 등의 소프트웨어는 안전성이 중요

#### 5) 사용성

- 소프트웨어를 사용할 때 혼란스러워하거나 사용하는 순간에 고민하지 않게 하는 편의성 



### 소프트웨어 개발에서의 모델

- 여러 설계도면을 보고 건물을 시공하는 것처럼, SW 개발에도 여러 관점의 모델을 사용
- UML 다이어그램을 이용한 표현
- 장점
  - 개발될 소프트웨어에 대한 이해도 향상, 이해 당사자 간의 **의사소통 향상**
  - 유지보수 용이
- 단점
  - 과도한 문서 작업으로 인한 일정 지연 가능성
  - 형식적인 산출물로 전략할 가능성

#### 모델링 언어

- 모델링 언어
  - 애매모호한 표현 등의 문제점 해결하기 위해 모델링 할 때 사용하는 기호, 표기법, 도구
  - 플로우를 만들 때, 정확하게 정의하기 위한 것
    - 예시) 악보 기호, 수학 기호, **UML 다이어그램**, Z 언어
- 개발 방법론에 따른 모델링 언어
  - 구조적 방법론: **DFD**(Data Flow Diagram), DD(Data Dictionary), 프로세스 명세
  - 정보공학 방법론: DB 설계 시 표현은 **ERD**(Entity-Relationship Diagram)
  - 객체지향 방법론: **UML** 표기법



#### DFD

- ![capture-5753345](images/Software_Enginnering/capture-5753345.png)
  - 사용자가 있고, 각각이 어떤 data를 사용하는지 설계하는 것

#### ER 다이어그램 

- 데이터베이스에 저장할 데이터를 개체 entity와 관계 relationship 중심으로 작성
- ![capture-5753386](images/Software_Enginnering/capture-5753386.png)



#### UML

- 유스케이스 다이어그램
- ![capture-5753458](images/Software_Enginnering/capture-5753458.png)
  - 사용자가 어떤 요구사항이 있고, 각각의 요구사항은 어떻게 communicate할 것인지 문서화



# 소프트웨어 개발단계: 설계/구현/테스트

## 설계

### 소프트웨어 설계 

#### 1. 분석 단계

- 사용자의 요구 사항으로 <u>요구 분석 명세서 작성</u>
- WHAT

#### 2. 설계 단계

- 비기능적 요구 사항과 제약 사항 고려
- 운영체제 (안드로이드, OS 등)/ 미들웨어/ 프레임워크 등의 **플랫폼 결정**
- <u>HOW</u>

#### 3. 설계

- <u>어떻게 구축</u>할 것인가
- 설계를 **평가**할 수 있는 기준 명시(정량적)
- 만든 후, 어떤 결과물이 나오고, 어떻게 평가할 것인지 명시



### 설계의 종류

#### 상위 설계

- 아키텍처(구조) 설계: 시스템의 전체적인 구조
- 데이터 설계: 시스템에 필요한 정보를 자료구조와 데이터베이스 설계에 반영
- 시스템 분할: 전체 시스템을 여러 개의 서브 시스템으로 나눈다.
- 인터페이스 정의: 시스템의 구조와 서브시스템들 사이의 인터페이스가 명확히 정의
- UI 설계: 사용자가 익숙하고 편리하게 사용할 수 있도록 사용자 인터페이스 설계

#### 하위 설계

- 각 모듈의 실제적인 내부를 알고리즘 (pseudo-code) 형태로 표현
- 인터페이스에 대한 설명, 자료구조, 변수 등에 대한 상세한 정보를 작성



### 소프트웨어 아키텍처

#### 아키텍처의 정의

- 구성 요소
- 구성 요소들 사이의 관계
- 구성 요소들이 외부에 드러내는 속성
- 구성 요소들과 주변 환경 사이의 관계
- 구성 요소들이 제공하는 인터페이스
- 구성 요소들의 협력 및 조립 방법



#### 소프트웨어 아키텍처

- 소프트웨어에 대한 전체적인 구조
- 소프트웨어를 이루고 있는 여러 구성 요소(서브시스템, 컴포넌트)
- 구성 요소들의 인터페이스 간의 상호작용 정의
- 시스템 설계와 개발 시 적용되는 <u>원칙과 지침</u>



### 소프트웨어 아키텍처 품질속성

#### 시스템 품질 속성

> 운영하는 서비스에 대한 시스템

- 가용성 (availability)
- 변경 용이성 (modifiability)
- 성능 (performance)
- 보안성 (security)
- 사용성 (usability)
- 테스트 용이성 (testability): 어떻게 하면 테스트를 잘할 것인지?

#### 비즈니스 품질 속성

> 아무리 좋은 아키텍처라고 하더라도, 시장에 맞지 않는다면 사용하지 못한다.

- 시장 적시성 (time to market)
- 비용과 이익 (cost and benefit)
- 예상 시스템 수명 (predicted lifetime of the system)
- 목표 시장 (targeted market)
- 신규 발매 일정 또는 공개 일정 (rollout schedule)
- 기존 시스템과의 통합 (integration with legacy system)

#### 아키텍처 품질 속성

- <u>개념적 무결</u>성 (conceptual integrity): **일관성**
- <u>정확성과 완전성</u> (correctness and completeness): 사용자가 요구하는 기능 (요구명세서)을 충족시키는 정도
- <u>개발 용이성</u> (구축 가능성, buildability): **정해진 기간 내**에 완성하고, 개발 과정 중에 쉽게 변경 가능



### 아키텍처 구축 절차

- **요구 사항 분석**
  - 요구 사항 취득, 식별, 명세, 분류, 검증
  - <u>기능적/ 비기능적 요구 사항 분류 및 명세</u>
- **아키텍처 분석**
  - 어떻게 아키텍처가 구성되어 있는지 분석
- **아키텍처 설계**
  - 관점 정의/ 아키텍처 <u>스타일</u> 선택/ <u>후보 아키텍처 도출</u>
- **검증 및 승인**
  - 아키텍처 평가/ <u>아키텍처 상세화 (반복)</u>/ <u>아키텍처 승인</u>



### 아키텍처 모델

#### 데이터 중심형 모델

![capture-5758120](images/Software_Enginnering/capture-5758120.png)

- repository model
- 주요 데이터가 repository에서 중앙 관리
- repository와 여기에 접근하는 서브 시스템으로 구성
- 데이터가 한군데에 모여 있기 때문에 데이터를 모순되지 않고 일관성 있게 관리 가능
- 새로운 서브시스템의 추가 용이
- repository의 병목 현상 발생 가능
- 서브시스템과 repository 사이의 강한 결합 
  - 단점: **repository 변경 시 모든 걸 다 변경되어야 하기 때문에, 서브시스템에 영향을 줌**



#### Client-Server 모델

![capture-5758191](images/Software_Enginnering/capture-5758191.png)

-  네트워크를 이용하는 분산 시스템 형태
- 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용
- 분산 아키텍처에 유용
- 서버: 클라이언트 (서브시스템)에 서비스 제공
- 클라이언트: 서버가 제공하는 서비스를 요청(호출)하는 서브 시스템



#### Layering 모델

![capture-5758231](images/Software_Enginnering/capture-5758231.png)

- 기능을 몇 개의 계층으로 나누어 배치
- 구성: 하위 계층은 서버, 상위 계층은 클라이언트 역할



####  Model/ View/ Controller 모델

<img src="images/Software_Enginnering/capture-5758292.png" alt="capture-5758292" style="zoom:25%;" />

- 중앙 데이터 구조
- 같은 모델의 서브 시스템에 대하여 **여러 뷰 시스템을 필요로 하는 시스템에 적합**
- 데이터베이스를 제어하는 컨트롤러, 컨트롤러는 사용자 사이에서 View 와 Browser를 조정
- 수정할 때, view, model, controller 따로따로 할 수 있고, 유지보수에 적합하다.
- 장점
  - 데이터를 화면에 표현(뷰)하는 디자인과 로직(모델)을 분리함으로써 느슨한 결합 가능
  - 구조 변경 요청 시 **수정 용이**
- 단점
  - 기본 기능 설계로 인한 클래스 수의 증가로 **복잡도 증가**
  - 속도가 중요한 프로젝트에 부적합 



### 디자인 패턴

#### 디자인 패턴

- 자주 사용하는 **설계 형태**를 <u>정형화</u>해서 이를 유형별로 <u>설계 템플릿</u>을 만들어둔 것
- 많은 개발자들이 경험상 체득한 설계 지식을 검증하고 이를 추상화하여 일반화한 템플릿
- 장점
  - 개발자 (설계자) 간의 원활한 의사소통
  - 소프트웨어 **구조 파악 용이**
  - 재사용을 통한 개발 시간 단축
  - 설계 변경 요청에 대한 유연한 대처
- 단점
  - 객체 지향 설계/구현 위주
  - 초기 투자 비용 부담

####  Got 디자인 패턴

##### A. Creational Pattern

-  객체를 생성하는데 관련된 패턴들
- 객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 함

##### B. Structural Pattern

- 프로그램 구조에 관련된 패턴들
- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들

##### C. Behavioral Pattern

- 반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들





### 모듈화

#### 모듈화

- 소프트웨어 개발에서 큰 문제를 <u>작은 단위</u>로 나누는 것

#### 모듈

- 기본적인 단위/ 논리적인 기능을 수행/ 독립 프로그램 / 함수(메서드)
- 차제적으로 기능할 수 있다.

#### 모듈화의 특징

- 다른 것들과 구별될 수 있는 <u>독립적인 기능</u>
- 유일한 이름
- <u>독립적으로 컴파일</u> (특히 라이브러리)
- 모듈에서 또 다른 모듈을 호출
- 다른 프로그램에서도 모듈을 호출

#### 모듈화의 형태

- 용도가 비슷한 것 끼리 묶어놓은 라이브러리 함수, 그래픽 함수
- 추상화된 자료, subroutine, procedure, object, method

#### 모듈화의 장점

- 분할과 정복 (Divide and conquer)의 원리가 적용
- 복잡도 감소
- 유지보수가 용이
- 오류로 인한 파급효과를 최소화
- 설계 및 코드를 재사용 



#### 응집도

- 모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도

##### 1. 기능적 응집: 응집도가 가장 높은 경우이며, 단일 기능의 요소로 하나의 모듈을 구성

##### 2. 순차적 응집: A 요소의 출력을 B 요소의 입력으로 사용

##### 3. 교환적 응집: 정보적 응집/ 구성 요소들이 동일한 출력을 생산

##### 4. 절차적 응집: 순서가 정해진 몇 개의 구성 요소를 하나의 모듈로 구성

##### 5. 시간적 응집: 구성 요소들이 같은 시간대에 함께 실행

##### 6. 논리적 응집: 요소들 간에 공통점 또는 비슷한 기능

##### 7. 우연적 응집: 크기가 커 몇 개의 모듈로 나누는 과정에서 우연히 같이 묶임



#### 결합도

- 모듈과 모듈 사이의 관계에서 관련 정도
- 어떻게 모듈끼리 결합해서 썼는지

##### 1. 데이터 결합: 모듈들이 매개변수를 통해 <u>데이터만 주고받음</u>으로써 서로 간섭을 최소화

##### 2. 스탬프 결합: 두 모듈 사이에서 정보를 교환할 때 필요한 데이터만 주고받을 수 없고, <u>스탬프처럼 필요없는 데이터까지 전체를 주고받아</u>야 하는 경우

##### 3. 제어 결합: 제어 플래그를 매개변수로 사용하여 간섭하는 관계

##### 4. 공통 결합: 모듈들이 공통 변수 (전역변수)를 같이 사용하여 발생하는 관계

##### 5. 내용 결합: 모듈 간에 인터페이스를 사용하지 않고 직접 왔다 갔다 하는 경우의 관계



### 바람직한 설계

- **<u>면접 TIP: 함수를 구현할 때 어떤 응집도와 어떤 결합도를 고려해 설계했다!</u>**

- 모듈 간에는 꼭 필요한 데이터만 주고받도록 적은 인터페이스의 수를 통한 약한 결합 유지
- 매개변수로 제어 플래그보다 데이터를 사용
- **유지 보수 용이성 향상**
- 낮은 결합도!와 높은 응집도!



### 방법론

#### 프로세스 지향 방법

- 처리순서를 <u>구조화</u>하는 방법
- 대표적인 모델 기법: DFD (Data Flow Diagram)
- 프로세스 지향 방법의 구성
- <u>기능이 중심</u> (우선)이 되고, 그 기능을 수행하는 데 필요한 데이터가 참조되는 형태로 구성
- <u>프로세스와 데이터의 분리</u>
- 실세계를 컴퓨터 처리 방식으로 표현
- 함수 중심 (우선)으로 모듈 구성



#### 데이터 지향 방법

- 시스템이 취급하는 <u>데이터에 관심</u>
- 즉 데이터가 중심(우선)이 되어 <u>데이터를 구조화</u>
- 대표적 소프트웨어 개발 방법론: 정보공학 방법론
- DB 설계를 위한 대표적 모델 표기법: E-REntity-Relationship 다이어그램



#### 프로세스 지향 방법과 데이터 지향 방법의 문제점

- **변경이 미치는 영향이 큼**: 프로세스와 데이터를 각각 별개의 것으로 파악하기 때문

- **프로그램의 복잡도 증가**: 함수와 데이터가 분리되어 있기 때문
- **프로그램 변경 시 프로그램 구조 파악 필요: **프로그래머는 프로그램의 구조와 영향을 미치는 곳도 파악해야 함
- **재사용의 어려움**: <u>프로세스와 데이터가 분리된 구조</u> 때문



#### 객체지향 방법 (object-oriented approach)

> 객체 안에는 동작도 있고 데이터도 존재

- 프로세스 지향 방법과 데이터 지향 방법의 문제점을 해결하기 위해 고안
- 기능이나 데이터 대신 객체가 중심이 되어 개발
- 데이터 (속성)를 가장 먼저 찾고, 그 데이터를 조작하는 메서드 (함수)를 찾아 그 둘을 객체라는 이름으로 묶어 그 객체를 중심으로 모듈 구성

##### 객체지향 방법의 특징

- 실세계를 **사람이 생각하는 방식**으로 표현한다.
- 임의로 데이터에 접근할 수 없다.
- 시스템은 **객체들의 모임**이다.
- 요구 사항 변경에 **유연하게 대처**할 수 있다.
- **확장성과 재사용성**이 높아진다.
- 추상화를 통해 **생산성과 품질**이 높아진다.



## 구현

### 프로그래밍 언어

![capture-5759350](images/Software_Enginnering/capture-5759350.png)

- 언어들의 표시! 
- 단일 언어로 가장 많이 사용하는 언어는: Java

### 코딩 규칙

![capture-5759237](images/Software_Enginnering/capture-5759237.png)

- 높은 가독성 (알기 쉽게 작성하기- 개발자들끼리 커뮤니케이션)
- 간결하고 명확한 코딩
- 개발 시간의 단축



## 테스트

### 테스트의 정의

#### 전문가들의 소프트웨어 테스트 정의

##### IEEE

- 테스트는 시스템이 명시된 요구를 잘 만족하는지, 즉 예**상된 결과와 실제 결과가 어떤 차이**를 보이는지 수동이나 자동으로 **검사하고 평가**하는 작업

##### Zoha Manna

- 테스트는 시**스템의 명세까지 완벽하게 옳다고 확신할 수 없고**, 테스트 시스템 그 자체가 맞다고 증명할 수 없기 때문에 **프로그램을 완전히 테스트 할 수 없다**.
  - 테스트를 완벽하게 할 수 없다!

##### Dahl, Dijkstra, Hoare

- 테스트는 **결함이 있음을 보여줄 뿐**, 결함이 없음을 증명할 수는 없다.



#### 소프트웨어 테스트 정의

- 소프트웨어 내에 **존재하지만 드러나지 않고 숨어있는 <u>오류</u>를 발견할 목적**
- 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업
- 오류를 찾아내 **정상적으로 실행될 수 있도록 하는 정도**
- 소프트웨어에 오류가 없음을 확인시켜주지는 못함
- 테스트는 오류를 찾고 올바르게 수정하여 프로그램을 작동시킬 수는 있지만, 그 프로그램이 **완전하고 정확하다고 증명할 수는 없다**.



### 소프트웨어 테스트의 목표

#### 작은 의미

- 원시 코드 속에 남아있는 **오류를 발견**하는 것
- **결함이 생기지 않도록 예방**하는 것

#### 큰 의미

- 개발된 소프트웨어가 **고객의 요구를 만족**시키는지 확인시켜주는 것
- 개발자와 고객에게 사용하기에 충분한 소프트웨어임을 보여주는 것
- 개발된 소프트웨어에 **신뢰성**을 높여주기 위한 작업



### 테스트에서 결함 관련 용어

#### 오류

- 소프트웨어 개발자에 의해 만들어지는 실수로 결함의 원인

#### 결함

- 오류에 의해 프로그램이 완전하지 못한 것으로, 고장의 원인

#### 고장, 실패, 문제, 장애

- 시스템이 요구 사항대로 작동하지 않는 것



### 테스트의 분류

#### 시각에 따른 테스트

##### 1) 확인 테스트 (verification test)

- 각 단계에서 개발자의 시각으로 테스트
- 설계도 대로 만들었는지 테스트 

##### 2) 검증 테스트 (validation test)

- 사용자의 요구 사항대로 만들었는지를 테스트
- 사용자의 시각에서 테스트

#### 사용 목적에 따른 테스트

- 운영 목적 적합성 테스트
- 수정 용이성 테스트
- 운영지원 용이성 테스트

#### 프로그램 실행 여부에 따른 테스트

- 정적 테스트: 프로그램을 실행하지 않고 코드를 검토하며 오류를 찾는 방법
- 동적 테스트: 프로그램을 실행하면서 오류를 찾는 방법



# 품질과 프로젝트 관리

## 품질

### 소프트웨어 품질 정의

---

#### '사용자의 <u>요구</u>와 부합되는 정도'

- US DoD- 개발된 소프트웨어가 사용자의 요구 사항을 만족할 수 있는 능력
- IEEE- 소프트웨어가 필요한 속성을 보유하고 있는 정도
  - 사용자의 기대 수준을 만족할 수 있는 정도를 결정하는 소프트웨어의 특성

#### 개발자 관점에서의 좋은 소프트웨어

- 결함 없는 프로그램
- <u>요구 분석 명세서대로</u> 만든 소프트웨어



### 품질 목표

---

#### 정확성

- 요구분석 명세서와 **일치**하는 정보

#### 신뢰성

- 기능이 정확하고 **일관성**있는 정도

#### 효율성

- **최소**의 시간과 저장용량을 사용

#### 무결성

- **허가받은** 사용자만 접근 또는 변경이 가능하다는 확실성

#### 접근사용성

- 사용자가 **순간 쉽게 이용**가능

#### 유지보수 용이성

- **쉽게 변경**할 수 있는 정도

#### 테스트 용이성

- **쉽고 철저**하게 테스트

#### 유연성

- 새로운 **기능의 추가 및 변경**의 용이성

#### 이식성

- 다른 **하드웨어 환경에서 운영할 수 있게 변경이 용이**

#### 재사용성

- 시스템의 일부나 전체를 다른 애플리케이션에서 **사용**할 수 있게 함

#### 상호운용성

- 다른 소프트웨어와의 **연계 및 결합하여 정보를 교환**할 수 있는 정도



# TIP :star: :star: :star: :star: :star:

- 회사 입사할 때, 그 회사의 서비스에 대한 분석을 해보는 것도 중요하다. 
- 예시: 카카오에 지원할 때, 카카오톡의 분석을 해보자.
- 우리 회사의 서비스에 대해 설명해보자 !
  - **제가 공부했던 품질 요소에 따르면: ~ 보헴에 따른 품질요소에 따르면 ~ 이런 부분을 개선했으면 좋겠습니다**.



### 품질 특성

---

#### McCall

- 제품수정/ 제품변환/ 제품운영

#### Garvin

- 성능/ 특성품질/ 신뢰성/ 일치성/ 내구성/ 서비스/ 미적/ 지각

#### Boehm

- 이식성/ 신뢰성/ 효율성/ 인간공학성/ 테스트성/ 이해성/ 수정(변경)성



### 품질 평가 표준 모델

---

#### 제품 품질 특성 평가

- 완성된 제품에 대한 평가
- ISO/IEC 9126에서 제시하는 모델이 소프트웨어 품질에 대한 표준적인 모델
- ISO/IEC 14598, ISO/IEC 12119, ISO/IEC 25000



#### 프로세스 품질 특성 평가

- 소프트웨어 품질의 개발 프로세스를 평가
- 소프트웨어 개발 과정의 각 단계마다 평가
- ISO/IEC 9000, ISO/IEC 12207, CMMI, SPICE



##### CMMI (Capability Maturity Model Integration)

> 기업에 표준 프로세스를 만들 수 있는 지침을 제시함
>
> - 조직의 프로세스에 대한 가이드이자 기준
> - '능력'과 '성숙도'로 조직의 프로세스를 측정하고 평가하는 모델이 통합 버전인 프로세스 개선 성숙도 모델
>
> 프로세스 품질을 평가, 조직이 소프트웨어를 개발하는 데에 있어서 그 프로세스가 얼마나 정립되어있는가 확인하는 것

- **C: Capability 능력** - 개발 목표 (주어진 기간, 정해진 비용, 고품질 등)를 달성할 수 있는 힘

- **M: Maturity 성숙도** - <u>책임감 있는 조직</u>으로서 개발 과정에서 <u>객관적이고 정량적</u>인 근거에 따라 <u>프로세스가 측정되고 지속적인 개선</u>이 이루어지는 조직

- **M: Model 모델**- 프로세스를 감사 (audit)하는 의미로 사용

- **I: Integration 통합** - 소프트웨어 개발 생명주기의 각 단계를 통합한 모델

  

##### SPICE (ISO 15504) 모델

> 소프트웨어 **프로세스 평가**를 위한 프레임워크 제공
>
> 정보 시스템 분야에 특화된 품질 표준이자 인증 규격의 역할

- 여러 소프트웨어 개발 회사들이 소프트웨어 프로세스를 평가를 하는 프레임워크를 제공한다



## 프로젝트 관리

### 프로젝트 정의 및 특징

---

> 소프트웨어를 개발하기 위한 과정에서 key는 사람이다
>
> 고객이란 사람을 만나 요구사항을 듣고, 개발을 하고, 기획을 한다.
>
> 그 사람들을 관리하는 프로세스를 어떻게 관리할거냐?
>
> 소프트웨어를 개발하는 조직에 대학 학문이다.
>
> - 개발하는 사람은 전체 과정에서 개발을 할 때 어떤것들을 고려해서 개발해야하는지
> - 전체적으로 프로세스를 관리하는 사람
> - 요구사항을 분석하고 서비스를 기획하는 사람
> - 서비스를 설계 하는 사람
>
> 각각의 사람과 직군에 대해, 개발자를 관리하는 사람
>
> 프로젝트 관리를 받는 입장에서, 어떤 요소가 있고 어떻게 하는지 알고 있자 :star: :star: :star: ​

#### 프로젝트 PMI

- 유일한 제품이나 서비스를 만들기 위해 일정한 기간을 정해놓고 수행하는 작업

#### 프로젝트의 특징

- **한시성**: 일의 <u>시작과 끝</u>이 명확히 정해져 있다.
- **유일성**: 기간이 종료되어 만들어 내는 <u>인도물</u>은 유일하다.
- **참여자의 일시성**: 참여 인력은 프로젝트 시작과 동시에 참여하고, <u>종료되면 해체</u>된다.
- **한정성**: 프로젝트가 종료되면 <u>사용된 자원은 원래의 위치</u>로 돌아가던가 없앤다



### PMBOK의 5가지 프로세스 그룹

---

1. **Initiating 시작 그룹**
   - 핵심 프로세스: 범위 관리 착수 및 프로젝트 또는 프로젝트를 <u>구성</u>하는 단계 정의 및 <u>승인</u>
2. **Planning 기획 그룹**
   - 프로젝트 목표 설정 및 목표 달성을 위한 활동 계획과 <u>예산, 인력, 자원</u> 등의 계획 수립
3. **Executing 실행 그룹**
   - 핵심 프로세스는 <u>프로젝트 계획 실행으로 계획을 세운대로 실제 프로젝트 수행</u>
4. **Controlling 통제 그룹**
   - 프로젝트 통제: 계획 대비 <u>목표의 진척 상황</u>을 주기적으로 감시하고 성과를 측정
5. **Closing 종료 그룹**
   - 프로젝트 종료: 관리의 종료 (구성원 평가), 계약 종료



### PMBOK의 9가지 관점

---

1. **통합**: 프로젝트 현장, 범위 진술서, 계획을 개발한다.
   - 프로젝트 변화를 지시하고 관리하며 모니터하고 통제한다
2. **범위**: 기획, 정의, 작업분류체계(WBS) 작성, 비준 및 통제
3. **시간**: 정의, 연결, 자원 및 기간 추정, 일정개발 및 일정관리
4. **비용**: 자원 기획, 비용 추정, 예산 및 통제
5. **품질**: 품질 계획, 품질보장 및 품질통제
6. **인적 자원**: 인적자원 계획, 인력충원, 인력개발 및 프로젝트 팀 관리
7. **통신**: 커뮤니케이션 계획, 정보 제공, 성과보고, 이해관계자 관리
8. **위험**: 리스크 계획 및 확인, 리스크 분석(양적, 질적), 리스크 대응(활동) 계획 및 리스크 모니터링 및 통제
9. **조**달: 휙득 및 계약 계획, 판매자 대응 및 선택, 계약관리 및 계약 종료



## 정보 시스템 감리

### 정보 시스템 감리의 정의

---

#### 정보 시스템 감리의 정의 (법 제2조 제14호)

- 감리발주자 및 피감리인의 이해관계로부터 독립된 자가 **정보시스템**의 효율성을 향상시키고 안전성을 확보하기 위하여 **제3자적 관점**에서 정보시스템의 구축 및 운영 등에 관한 사항을 **종합적으로 점검하고 문제점을 개선**하도록 하는 것

#### 전자정부법

- **제1조(목적)** 이 법은 행정업무의 전자적 처리를 위한 기본원칙, 절차 및 추진방법 등을 규정함으로써 전자정부를 효율적으로 구현하고, 행정의 생산성, 투명성 및 민주성을 높여 국민의 삶의 질을 향상시키는 것을 목적으로 한다.
- **제2조(정의)** 이 법에서 사용하는 용어의 뜻은 다음과 같다. 
- 13. "정보시스템"이란 정보의 수집ㆍ가공ㆍ저장ㆍ검색ㆍ송신ㆍ수신 및 그 활용과 관련되는 기기와 소프트웨어의 조직화된 체계를 말한다.

- 14. "정보시스템 감리"란 감리발주자 및 피감리인의 이해관계로부터 독립된 자가 정보시스템의 효율성을 향상시키고 안전성을 확보하기 위하여 제3자의 관점에서 정보시스템의 구축 및 운영 등에 관한 사항을 종합적으로 점검하고 문제점을 개선하도록 하는 것을 말한다.

### 정보시스템 감리의 정의: 감리목적

---

#### 정보 시스템의 효과성 확보

- 정보시스템이 사전에 설정된 **목표(**예: 업무 자동화, 고객에 대한 서비스 개선 등)를 달성하도록 함

#### 정보 시스템의 효율성 확보

- 사용자 측면: **응답시간**
- 시스템 측면: **최대 처리량, 자원이용도(CPU, 메모리, 디스크)**

#### 정보 시스템 안전성 (Security) 확보

- **무결성, 가용성, 기밀성**

#### 법적 요건의 준수 확인

- **업무와 관련된 기준, 규정,** 정보화 사업 추진과 관련된 규정 등



### 정보시스템 감리의 정의

---

#### 감리대상

- 정보시스템의 구축 및 운영 등

#### 정보시스템 구축(개발) 사업

- DB 구축사업
- 운영사업
- 유지 보수 사업
- ISP 사업
- ITA 사업 등



### 의무 감리대상

---

#### 주요 공공 정보시스템 감리를 의무화(법 제 57조 1)

#### 의무 감리 대상 기준(시행령 제71조1 제1, 2호)

- 정보 시스템의 특성, 사업의 규모 측면에서 판단 기준을 제시
- 규모기준: 사업비 ( HW, SW의 단순구입비 제외) <u>5억원 이상인 정보시스템 구축사업</u>
- 특성기준: 1. 대국민 서비스/ 민원 업무 2. 다수기관 공동 구축/사용 (1억원 미만으로 감리의 비용대비효과가 낮다고 장이 인정하는 경우는 제외)

#### 선택적 감리대상기준 (시행령 제 71조1 제 3호)

#### 기타 ITA ISP, 운영 등 감리 시행이 필요하다고 행정기관의 장이 인정하는 경우



### 감리관련 준수사항

---

#### 발주자 의무 준수 사항 (법 제57조2)

- 소속직원 및 사업자에 대한 감리 업무수행 필요사항 지원 지시
- 부당한 업무 개입 ・ 간섭 금지

#### 감리결과 반영 의무화 (법 제57조3)

- 주체: 행정기관등의 장
- 반영내용: 감리결과
- 수행자: 정보시스템 구축 사업자

#### 감리기준의 고시 및 준수 (법 제 57조 5~6)

- 정보시스템 감리기준 (감리를 하기 위하여 필요한 기준) 제정・고시





## IT 기술용어 정리

### 데이터 마이닝 (Data Mining)

---

#### Data Mining의 정의

- 데이터가 아주 많은데, 요구사항에 맞게 의미있는 정보와 지식을 분석해 추출하는 것
- 데이터가 아주 많이 모아놓으면, 사용자한테 필요한 데이터를 분석해 추출하는 것

- 대용량의 데이터로부터 사용자의 요구사항에 맞는 의미있는 정보와 지식을 분석하여, 추출하는 방법

#### Data Mining의 등장배경

##### 기술적 측면

- **프로세싱 속도 및 자료저장 구조**, **기계학습** (Machine Learning) 기술의 발전
- **대량의 데이터 축적 및 데이터마이닝 도구의 발전**

##### 비즈니스 측면

- Mass 마케팅에서 Target 마켓팅으로의 패러다임 변화
- 대량의 데이터로부터 의미있는 정보 추출을 통한 기업의 새로운 비즈니스 창출/개선/활용

#### Data Mining과 OLAP의 개념도

![capture-5839356](images/Software Enginnering/capture-5839356.png)

- 수많은 데이터가 쌓여있는데, 도구를 통해 분석하고, 처리해서, 사용한다.



### 웹 마이닝 (Web Mining)

---

#### 웹 마이닝 (Web Mining)의 정의

- **웹 환경**에서 얻어지는 **웹 문서**, <u>고객의 정보 및 데이터로부터 특정 행위, 패턴</u> 등의 유용한 정보를 이용하여 **마케팅** 및 의사결정에 활용하기 위한 마이닝 기법
- 페이스북: 스크롤할 때 어떤 기사를 오랫동안 보고 있는지도 수집되고 있음. 클릭 이외에도 핼동에 대한 패턴도 수집되고 있다.

#### 웹 마이닝 (Web Mining)의 특징

##### 대용량

- 대량의 웹로그를 기반으로 정보를 수집, 자료를 제정 및 클리닝 수행

##### 실시간성

- Batch 작업 성격이 강한 일반 데이터 마이닝과 구별

##### One-to-one

- 고객 행위 분석을 통한 개인화 지향 (데이터 마이닝은 일반화)

##### 마이닝 기법

- 신경망, 연관성, 순서화, 군집화, 의사결정 등을 마이닝 기법 활용



### BCP (Business Continuity Planning)

---

####  BCP (Business Continuity Planning)의 정의

> 지진, 홍수, 천재지변 재해발생 시, **시스템의 복구 데이터 복원** 등과 같은 단순 **복구차원**을 포함하여, **기업 비즈니스 연속성을 보장할 수 있는 체계**



#### BCP의 등장 배경

##### 기술적 배경

- 재해대비 시스템 **복구 기능**이 정보시스템 필수 요소 인식
- 기업 IT 시스템 **안정성**에 대한 법적 규제 추세

##### 내부환경 측면

- 시스템 중지로 인한 영업손실에 대한 **기회 비용 발생 방지**
- **재해 발생시** 조직 및 개인의 **업무 정의 필요**

##### 외부환경 측면

- **고객정보 보호 및 업무 연속성 확보를 위한 안전장치 마련**

- 시스템 중단 시 발생하는 기**업이미지 실추 예방**



#### BCP 프레임워크내의 주요 계획

##### 재해예방 (Disaster Prevention)

- 재해 (Disaster)가 발생하기 전에 재해발생요인을 사전에 대응, 처리
- 위기관리 (Crisis Mgt)를 통한 사전에 위기를 정성적, 정량적 분석을 통하여 예방함

##### 대응 및 복구 (Response & Recovery)

- 재해에 대하여 정성적, 정량적 평가항목을 도출
- BIA (Business Impact Analysis)를 통한 파급효과를 분석하고 대응방안 수립
- Contingency Plan을 통한 복구 수립

##### 유지보수 (Maintenance)

- 운영형태별 센터유형을 선택
- 상호계약형, 공동이용형, 위탁운영형, 자영운영형 중에 선택
- TCO 및 ROI 분석을 통한 효율화 필요
- DR 거리에 따른 Annual Charge 고려 필요

##### 모의훈련 (Simulation)

- 수립된 계획의 주기적인 테스트 (최소 연 1회)를 통한 미비점 파악 및 보안
- 복구목표시간 (RTO), 목표수준(RPO) 실제 훈련적용

##### BCP 예시

- ![capture-5839917](images/Software_Enginnering/capture-5839917.png)



### BCM (Business Continuity Management)

---

#### BCM (Business Continuity Management) 정의

- 예기치 않은 상황에서도 비즈니스를 **지속적으로 운영**하기 위해, 시스템 복구 등과 같은 24시간 365일 **기업 비즈니스 연속성을 보장할 수 있는 경영**

#### BCM의 특징

- 복원능력 (Resilience) - 업무 중단 발생 시 <u>견뎌낼 수 있는</u> 능력
- 반복훈련(Simulation)- 계획이 예상대로 수행되고, **개선됨**을 보장
- 업무중단관리-**IMP**(Incident Management Plan, 사고초기확산통제)/ **BCP**(Business Continuity Plan,핵심 프로세스 지속 보장)

#### BCM 수행절차

- ![capture-5840088](images/Software_Enginnering/capture-5840088.png)



### DRS (Disaster Recovery System)

---

#### DRS (Disaster Recovery System)의 정의

- 정보시스템에 대한 **비상 대비체계 유지**와 각 업무 조직별 비상사태에 대비한 **복구계획 수립을 통한 업무 연속성을 유지할 수 있는 체제**

#### DRS의 필요성

- 고배대지진, 911테러, 2003년 인터넷 대란 등 재해 장애 상황에서 재해복구를 통한 서비스의 연속성이 필요
- 업무 중단으로 인한 기업 손실 및 신뢰도 하락을 방지

#### DRS (Disaster Recovery System) 구축절차

- ![capture-5840245](images/Software_Enginnering/capture-5840245.png)



### BIA (Business Impact Analysis)

---

#### BIA (Business Impact Analysis)의 정의

- 재해 발생 시 영향을 미칠 수 있는 **위험을 정의**하고, 업무중단 영향에 대한 **정량적/ 정성적 분석**을 통해 복구 우**선순위를 도출하는 과정**

#### BIA의 목적

##### 핵심 우선순위 결정

- 모든 핵심적 사업단위 프로세스에 우선순위를 부여함

##### 중단시간 산정

- 경쟁력 있는 기업으로 살아남기 위해 견딜 수 있는 최대 극복상태로 빠지기 전까지 견딜 수 있는 최장시간의 산정

##### 자원 요구

- 핵심 프로세스에 대한 자원 요구사항도 이 때 정의되는데, 시간에 민감한 프로세스에 대부분의 자원이 할당됨



# 면접 기출문제

## 왜 소프트웨어 공학이 필요할까요?



## 소프트웨어 개발 경험을 설명해보시오.



## Agile 방법론에 대해서 설명하시오.



## Lean 개발 방법론에 대해서 설명하시오.



