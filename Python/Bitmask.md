# Bitmask

## 비트

### 비트란? 

- 이진 숫자 (binary digit)을 뜻하며, 컴퓨터에서 사용되는 최소 단위이다.

- 비트는 0, 1의 값을 가질 수 있으며, 이는 true/false 혹은 on/off라는 상태를 가진다.

- 코드에서 2진수를 type하려면:

  - 0b + 2진수

- 예시: 10진수 11을 2진수로 바꿔보자.

  

  ![img](/Users/chaelinshin/Documents/TIL_selfstudy/Python/Bit Operator.assets/img.png)

  [출처]: https://mygumi.tistory.com/361

  

  - 파이썬에서 10진수를 2진수로 변환하는 방법

    ```python
  bin(number)
    bin(13)
    #'0b1101'
    ```
  
    



- 예시: 2진수 1101을 10진수로 바꿔보자

  <img src="https://dojang.io/pluginfile.php/14088/mod_page/content/4/047001.png" alt="2진수를 10진수로 바꾸기" style="zoom: 50%;" />

  [출처]: https://dojang.io/mod/page/view.php?id=2460

  

  - 2진수를 10진수로 변환

    ```python
  #2진수
    0b1101 #13
    
    #2진수가 문자열 형태라면?
    int('1101', 2) #13
    ```
  
    

### 비트 논리 연산자

- 2진수의 각 자릿수를 AND, OR, XOR, NOT연산을 하는 비트 논리 연산를 사용해보자.

#### x & y

- AND 연산

- 대응하는 두 비트가 모두 1일 때 (둘 다 참일 때), 1을 반환

  ```python
  bin(0b1101 & 0b1001)
  #'0b1001'
  13 & 9 
  #9 (10진수를 2진수로 바꿔서 계산)
  ```

  

#### x | y

- OR 연산

- 대응하는 두 비트가 모두 1 또는 하나라도 1일 때 (둘 중 하나라도 참일 때), 1을 반환

  ```python
  bin(0b1101 | 0b1001)
  #'0b1101'
  13 | 9
  # 13
  
  ```

  



#### x ^ y

- XOR 연산
- 대응하는 두 비트가 서로 다르면 (둘 중 하나만 참일 때) 1을 반환

```python
bin(0b1101 ^ 0b1001)
#'0b100'
13 ^ 9 
#4
```



#### ~x

- NOT 연산

- 비트의 값을 반전하여 전환, 보수 연산

- x의 비트를 뒤집어 1을 0으로, 0을 1으로 바꾼다.

-  -x-1의 값과 같다.

  ```python
  bin(~0b1101)
  #'-0b1110'
bin(~0b1010)
  #'-0b1011'
  ~13
  #-14
  ```
  
  

### 쉬프트 연산 

#### x  <<  y

- x 비트를 y번 왼쪽으로 이동시킨다.

- x * 2**y 값과 같다.

  

#### x >> y

- x 비트를 y번 오른쪽으로 이동시킨다.
- x // 2**y 값과 같다



```python
0b0011 << 2
#12
bin(12)
#'0b1100'

0b1100 >> 2
# 3
bin(3)
#'0b11'
```



#### 시프트 연산의 활용

- x * 2**y
  - x를 2의 y제곱만큼 곱해주는 연산으로, **x<<y**로 구현 가능
- x / 2**y
  - x를 2의  y제곱만큼 나눠주는 연산으로 **x>>y**로 구현가능
- N%2 ==1
  - N이 짝수인지 홀수인지 판별하기 위해서 2로 나눈 나머지를 구해 1과 비교하는 연산이다.
  - N &1로 구현이 가능하다.
    - N이 짝수일 경우 이진수로 표현했을 때 맨 뒤가 0으로 표현된다. 이를 1과 and연산을 실행하게 되면 0이 나오게 된다.
    - N이 홀수 일경우에는 맨 뒤가 1로 표현된다. 이를 1과 and연산하게 되면 1이 나오게 된다.



### 비트마스크란 무엇인가?

- 이러한 비트의 형태를 활용해, **정수의 이진수 표현을 활용한** 기법이다.



#### 장점

- 수행시간이 빠르다.
- 코드가 간결하다.
- 메모리 사용량이 적다.



#### 집합의 어떤 요소를 구성하고 있는지 집합 표현하기

```
{ 0, 1, 2, 3, 4 } => 11111
{ 1, 2, 3, 4 } => 11110
{ 1, 2, 4 } => 10110
{ 2, 4 } => 10100
{ 1 } => 00010
```



- 위의 부분집합을 배열이 아닌 **정수**로 아래와 같이 나타낼 수 있다.

```
{ 0, 1, 2, 3, 4 } => 11111 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) + (2^0 * 1) = 31
{ 1, 2, 3, 4 } => 11110 => (2^4 * 1) + (2^3 * 1) + (2^2 * 1) + (2^1 * 1) = 30 
{ 1, 2, 4 } => 10110 => (2^4 * 1) + (2^2 * 1) + (2^1 * 1) = 22
{ 2, 4 } => 10100 => (2^4 * 1) + (2^2 * 1) = 20
{ 1 } => 00010 => (2^1 * 1) = 2
```

- 위와 같이, {1, 2, 4} 부분집합에서 i를 추가하고 싶으면, 단순히 i번째 비트의 값을 1로 변경해주면 된다.
- 이를 통해 **삽입, 삭제, 조회**와 같은 행위를 비트 연산을 통해 쉽게 실행할 수 있다.



#### 비트마스크 연산

- 비트마스크를 활용하기 위해 실행할 수 있는 핵심적인 연산이 있다.

- 집합을 A라고 하고, 변수를 i라고 한다.

  

##### A에 i가 포함되어있는가?

```python
A & (1<<i)
#포함되어 있을 경우 2**i, 포함되어 있지 않을 경우, 0
```



##### A에 i를 추가한다

```python
A = A|(1<<i)
```



##### A에 i를 제거한다

```python
A = A & ~(1<<i)
```



##### A에 i가 있으면 제거하고, 없으면 추가한다.

```python
A = A ^ (1<<i)
```



##### A에 1로 가득 채운다.

```python
A = (1 << N) - 1
```





